Why does it activate in the first predict but not in delete? 

Why doesn't modify activate given it doesn't fire and would be helpful if it did?
	-Because it's just position differences

'''	

	OLD SLOPPY
	for stateIndex in range(0, maxFrame-1):
		#print ("")
		print ("Sloppy Rule Building State: "+str(stateIndex))

		state = stateSequence[stateIndex]
		state = currEngine.predict(state)#predict
		nextState = stateSequence[stateIndex+1]

		#state.SetupDeltaFacts(nextState)

		#Current to next mapping 
		components1To2Mappings = state.components1To2Mappings
		#Next to current mapping
		components2To1Mappings = state.components2To1Mappings

		if stateIndex>0:
			lastState = stateSequence[stateIndex-1]
			lastOtherToThis = lastState.components1To2Mappings
			lastThisToOther = lastState.components2To1Mappings
		else:
			lastState = stateSequence[stateIndex+1]
			lastOtherToThis = state.components2To1Mappings
			lastThisToOther = state.components1To2Mappings

		factsExceptDifferences = state.GetAllFacts()
		toRemove = []
		for cKey in state.factsByComponentID.keys():
			if cKey==-1:
				for fact in state.factsByComponentID[cKey]:
					for lastFact in lastState.factsByComponentID[-1]:
						if fact.CheckMatchBesidesID(lastFact):
							toRemove.append(fact)
							break

			elif cKey in lastThisToOther.keys() and lastThisToOther[cKey] in lastOtherToThis.keys() and cKey==lastOtherToThis[lastThisToOther[cKey]]:
				for fact in state.factsByComponentID[cKey]:
					for lastFact in lastState.factsByComponentID[lastThisToOther[cKey]]:
						if fact.CheckMatchBesidesID(lastFact):
							toRemove.append(fact)
							break
		for r in toRemove:
			factsExceptDifferences.remove(r)

		totalComponents = len(state.components)
		for i in range(0, totalComponents):

			if i<len(state.components):
				#print ("Component: "+str(state.components[i]))
				if i in state.components1To2Mappings.keys() and state.components1To2Mappings[i] in state.components2To1Mappings.keys() and i==state.components2To1Mappings[state.components1To2Mappings[i]]:#if it matches

					#Find all differences between matched components. Assume they must be accounted for by rules
					preEffects = []
					postEffects = []
					for fact in state.factsByComponentID[i]:
						#print ("	Fact: "+str(fact))
						if not isinstance(fact, RelationshipFactX) and not isinstance(fact, RelationshipFactY) and not isinstance(fact,PositionXFact) and not isinstance(fact, PositionYFact):
							matched = False
							closestFact = None
							for fact2 in nextState.factsByComponentID[state.components1To2Mappings[i]]:
								if fact.CheckMatchBesidesID(fact2):
									matched = True
									break
								elif isinstance(fact, fact2.__class__):
									closestFact = fact2
							
							if not matched and not closestFact == None:
								preEffects.append(fact)
								postEffects.append(closestFact)	
								#print ("Adding: "+str(fact)+" to "+str(closestFact)+" cids "+str([i, fact.componentID, closestFact.componentID]))


					for index in range(0, len(preEffects)):
						#check to see if this could be handled by another rule
						modified = False
						for r in range(0, len(currEngine.rules)):
							#If the post effect matches modify rule
							if currEngine.rules[r].postEffect.CheckMatchBesidesID(postEffects[index]):
								#Determine if rule would have fired
								fired, effectIds = currEngine.rules[r].ConditionSatisfiedCheck(state)

								if not fired: 
									#Find new set of conditions that would have lead this rule to fire
									newConditions = []
									preEffect = currEngine.rules[r].preEffect.clone()
									for cond in currEngine.rules[r].conditions:
										matched = False

										for fact in factsExceptDifferences:
											if cond.CheckMatchBesidesID(fact):
												matched = True
												newConditions.append(cond)
												break
										if not matched and not isinstance(cond, AnimationFact):
											#check if either of the two inequalities of this condition match
											inequalities = [InequalityFact(cond, cond.GetValue(), ">="), InequalityFact(cond, cond.GetValue(), "<=")]
											for ineqaulityCond in inequalities:
												for fact in factsExceptDifferences:
													if ineqaulityCond.CheckMatchBesidesID(fact):
														matched = True
														newConditions.append(ineqaulityCond)
														if cond==preEffect:
															preEffect = ineqaulityCond
														break
												if matched:
													break
									if len(newConditions)>1:#TODO; threshold parameter?
										modified = True
										#print ("")
										#print ("Modifying Rule")
										#print ("Old rule: "+str(currEngine.rules[r].preEffect)+"->"+str(currEngine.rules[r].postEffect))
										currEngine.rules[r] = Rule(newConditions, preEffect, postEffects[index])
										#We made it work, so we can keep going
										#print ("New rule: "+str(currEngine.rules[r].preEffect)+"->"+str(currEngine.rules[r].postEffect))
										break
								else:
									if preEffect.componentID in effectIds:
										modified = True
										break

						if not modified:
							condition = list(factsExceptDifferences)
							condition.append(preEffects[index])
							for stateCond in state.factsByComponentID[preEffects[index].componentID]:
								if not stateCond in condition:
									condition.append(stateCond)
							currEngine.addRule(Rule(condition, preEffects[index], postEffects[index]))
							#print ("")
							#print ("Adding rule: "+str(preEffects[index])+"->"+str(postEffects[index])+" of components: "+str(state.components[preEffects[index].componentID])+" and "+str(nextState.components[postEffects[index].componentID]))
				
				elif len(state.components)>len(nextState.components) and not i in state.components1To2Mappings.keys():#No perfect match, did this disappear?
					
					condition = list(factsExceptDifferences)
					listAllFacts = []
					for fact in state.factsByComponentID[i]:
						listAllFacts.append(fact)
					for stateCond in state.factsByComponentID[i]:
						if not stateCond in condition:
							condition.append(stateCond)
					#remove all of them
					currEngine.addRule(Rule(condition, EmptyFact(listAllFacts), EmptyFact([])))
					#print ("")
					#print ("Adding (2) rule: "+str(EmptyFact(listAllFacts))+"->"+str(EmptyFact([])))
				
		if len(nextState.components)>len(state.components):#Appearing rules
			for j in range(0, len(nextState.components)):
				if not j in state.components2To1Mappings.keys():#unmatched, might have appeared

					minRelationshipFacts = nextState.GetMinRelationshipFactsToComponents(j, state.components)

					condition = list(factsExceptDifferences)
					#add all of them after the relationship facts
					for fact in nextState.factsByComponentID[j]:
						if not isinstance(fact, PositionXFact) and not isinstance(fact, PositionYFact):
							minRelationshipFacts.append(fact)

					currEngine.addRule(Rule(condition, EmptyFact([]), EmptyFact(minRelationshipFacts)))

					#print ("")
					#print ("Adding (3) rule: "+str(EmptyFact([]))+"->"+str(EmptyFact(minRelationshipFacts)))
	'''